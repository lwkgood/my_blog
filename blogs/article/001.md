---
title: JavaScript 进阶问题列表
date: 2022-9-6
categories: 
 - Article
tags:
 - Article
sidebar: 'auto'
---

## 1.输出是什么
```js
function sayHi() {
    console.log(name);
    console.log(age);
    var name = 'Lydia';
    let age = 21;
}
```

+ A：`Lydia` 和 `undefined`
+ B：`Lydia` 和 `ReferenceError`
+ C：`ReferenceError` 和 `21`
+ D：`undefined` 和 `ReferenceError`

<details>
<summary>答案</summary>
<p>
<strong>答案：D</strong>
</p>
<p>在函数内部，我们首先通过 <code>var</code> 关键字声明了 <code>name</code> 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 <code>undefined</code>。因为当我们打印 <code>name</code> 变量时还没有执行到定义变量的位置，因此变量的值保持为 <code>undefined</code>
</p>
<p>
通过 <code>let</code> 和 <code>const</code> 关键字声明的变量也会提升，但是和 <code>var</code> 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，<code>JavaScript</code> 将会抛出一个 <code>ReferenceError</code> 错误
</p>
</details>

## 2.输出是什么
```js
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 1)
}
```
+ A: `0 1 2` 和 `0 1 2`
+ B: `0 1 2` 和 `3 3 3`
+ C: `3 3 3` 和 `0 1 2`

<details>
<summary>答案</summary>
<p>
<strong>答案：C</strong>
</p>
<p>
由于 <code>JavaScript</code> 的事件循环，<code>setTimeout</code> 回调会在遍历结束后才执行。因为在第一个遍历中遍历 <code>i</code> 是通过 <code>var</code> 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 <code>++</code> 来每次递增 <code>i</code> 的值。当 <code>setTimeout</code> 回调执行的时候，<code>i</code> 的值等于 <code>3</code>
</p>
<p>
在第二个遍历中，遍历 <code>i</code> 是通过 <code>let</code> 关键字声明的：通过 <code>let</code> 和 <code>const</code> 关键字声明的变量是拥有块级作用域（指的是任何在 <code>{}</code> 中的内容）。在每次的遍历过程中，<code>i</code> 都有一个新值，并且每个值都在循环内的作用域中
</p>
</details>

## 3.输出是什么

```js
const shape = {
    radius: 10,
    diameter() {
        return this.radius * 2
    },
    perimeter: () => 2 * Math.PI * this.radius
}

shape.diameter()
shape.perimeter()
```

+ A: `20` and `62.83185307179586`
+ B: `20` and `NaN`
+ C: `20` and `63`
+ D: `NaN` and `63`

<details>
<summary>答案</summary>
<p>
<strong>答案：B</strong>
</p>
<p>
注意 <code>diameter</code> 的值是一个常规函数，但是 <code>perimeter</code> 的值是一个箭头函数
</p>
<p>
对于箭头函数，<code>this</code> 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 <code>perimeter</code> 时，<code>this</code> 不是指向 <code>shape</code> 对象，而是它的周围作用域（在例子中是 <code>window</code>）
</p>
<p>
在 <code>window</code> 中没有 <code>radius</code> 这个属性，因此返回 <code>undefined</code>
</p>
</details>

## 4.输出是什么

```js
+true;
!"Lydia";
```

+ A: `1` and `false`
+ B: `false` and `NaN`
+ C: `false` and `false`

<details>
<summary>答案</summary>
<p>
<strong>答案：A</strong>
</p>
<p>
一元操作符加号尝试将 <code>boolean</code> 转为 <code>number</code>。<code>true</code> 转换为 <code>number</code> 的话为 <code>1</code>，<code>false</code> 为 <code>0</code>
</p>
<p>
字符串 <code>'Lydia'</code> 是一个真值，真值取反那么就返回 <code>false</code>
</p>
</details>

## 5.哪一个正确

```js
const bird = {
    size: 'small'
}

const mouse = {
    name: 'Mickey',
    small: true
}
```

+ A: `mouse.bird.size`是无效的
+ B: `mouse[bird.size]`是无效的
+ C: `mouse[bird["size"]]`是无效的
+ D: 以上三个选项都是有效的

<details>
<summary>答案</summary>
<p>
<strong>答案：A</strong>
</p>
<p>
在 <code>JavaScript</code> 中，所有对象的 <code>keys</code> 都是字符串（除非对象是 <code>Symbol</code>）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串
</p>
<p>
当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 <code>[</code> 并继续前进直到找到结束括号 <code>]</code>。只有这样，它才会计算语句的值
</p>
<p>
<code>mouse[bird.size]</code>：首先计算 <code>bird.size</code>，这会得到 <code>small</code>。<code>mouse["small"]</code> 返回 <code>true</code>
</p>
<p>
然后使用点语法的话，上面这一切都不会发生。<code>mouse</code> 没有 <code>bird</code> 这个 <code>key</code>，这也就意味着 <code>mouse.bird</code> 是 <code>undefined</code>。然后当我们使用点语法 <code>mouse.bird.size</code> 时，因为 <code>mouse.bird</code> 是 <code>undefined</code>，这也就变成了 <code>undefined.size</code>。这个行为是无效的，并且会抛出一个错误类似 <code>Cannot read property "size" of undefined</code>
</p>
</details>

## 6.输出是什么

```js
let c = { greeting: 'Hey!' }
let d

d = c
c.greeting = 'Hello'
console.log(d.greeting)
```

+ A: `Hello`
+ B: `undefined`
+ C: `ReferenceError`
+ D: `TypeError`

