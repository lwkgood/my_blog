---
title: JavaScript 进阶问题列表
date: 2022-9-6
categories: 
 - Article
tags:
 - Article
sidebar: 'auto'
---

## 1.输出是什么？
```js
function sayHi() {
    console.log(name);
    console.log(age);
    var name = 'Lydia';
    let age = 21;
}
```

+ A：`Lydia` 和 `undefined`
+ B：`Lydia` 和 `ReferenceError`
+ C：`ReferenceError` 和 `21`
+ D：`undefined` 和 `ReferenceError`

<details>
<summary>答案</summary>
<p>
<strong>答案：D</strong>
</p>
<p>在函数内部，我们首先通过 <code>var</code> 关键字声明了 <code>name</code> 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 <code>undefined</code>。因为当我们打印 <code>name</code> 变量时还没有执行到定义变量的位置，因此变量的值保持为 <code>undefined</code>
</p>
<p>
通过 <code>let</code> 和 <code>const</code> 关键字声明的变量也会提升，但是和 <code>var</code> 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，<code>JavaScript</code> 将会抛出一个 <code>ReferenceError</code> 错误
</p>
</details>

## 2.输出是什么？
```js
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 1)
}
```
+ A: `0 1 2` 和 `0 1 2`
+ B: `0 1 2` 和 `3 3 3`
+ C: `3 3 3` 和 `0 1 2`

<details>
<summary>答案</summary>
<p>
<strong>答案：C</strong>
</p>
<p>
由于 <code>JavaScript</code> 的事件循环，<code>setTimeout</code> 回调会在遍历结束后才执行。因为在第一个遍历中遍历 <code>i</code> 是通过 <code>var</code> 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 <code>++</code> 来每次递增 <code>i</code> 的值。当 <code>setTimeout</code> 回调执行的时候，<code>i</code> 的值等于 <code>3</code>
</p>
<p>
在第二个遍历中，遍历 <code>i</code> 是通过 <code>let</code> 关键字声明的：通过 <code>let</code> 和 <code>const</code> 关键字声明的变量是拥有块级作用域（指的是任何在 <code>{}</code> 中的内容）。在每次的遍历过程中，<code>i</code> 都有一个新值，并且每个值都在循环内的作用域中
</p>
</details>





