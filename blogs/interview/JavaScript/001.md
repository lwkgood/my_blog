---
title: 基础
date: 2022-8-30
categories: 
 - Interview
tags:
 - Interview
sidebar: 'auto'
---

## DOM常用API

可使用 `document` 或 `window` 元素的 API 操作文档本身 或 获取文档的子类（Web 页面中的各种元素）
```js
// 获取元素
const node = document.getElementById(id);
const node1 = document.querySelector(".class|#id|name");

// 创建元素
const heading = document.createElement(name); // name: p、div、h1...
heading.innerHTML = '';

// 添加元素
document.body.appendChild(heading);

// 删除元素
document.body.removeChild(node);
```

示例：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>DOM 操作</title>
    <style>
        div {
            border: 1px solid #ccc;
            padding: 50px;
            width: 100px;
        }
    </style>
</head>
<body>
    <div id="dom1">元素 1</div>
    <div class="dom2">元素 2</div>

    <button class="btn">点我</button>
</body>
<script>
    (function() {
        const btn = document.querySelector('.btn');

        // 注册点击事件
        btn.onclick = function() {
            const dom1 = document.getElementById('dom1');

            // 第一种添加元素
            const newDom1 = document.createElement('p');
            newDom1.innerHTML = '<a href="https://lwkgood.github.io/my_blog/">Mike Blog</a>';
            dom1.appendChild(newDom1);

            // 第二种添加元素
            const newDom2 = document.createElement('ul');
            newDom2.innerHTML = `
                <li>aaa</li>
                <li>bbb</li>
            `;
            document.body.appendChild(newDom2);

            // 移除元素
            const dom2 = document.querySelector('.dom2');
            document.body.removeChild(dom2);
        }
    })();
</script>
</html>
```

## null 和 undefined 区别

使用场景细分如下：

一、null:
1. `Number(null) = 0`
2. 作为函数的参数，表示该函数的参数不是对象
3. 作为对象原型链的终点 `Object.prototype.__proto__ === null`

二、undefined
1. `Number(undefined) = undefined`
2. 变量被声明但没有赋值 = undefined
3. 调用函数时，对应的参数没提供 = undefined
4. 对象没有赋值，这个属性的值 = undefined
5. 函数没有返回值，默认返回 undefined

## 事件流

什么是事件流：描述从页面中接收事件的顺序

`DOM 2级`事件流包括下面几个阶段：
1. 事件捕获阶段
2. 处于目标阶段
3. 事件冒泡阶段

如何让事件先冒泡后捕获：

在 `DOM` 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间

### addEventListener

addEventListener 方法将指定的监听器注册到 `EventTarget` 上，当该对象触发指定的事件时，指定的回调函数就会被执行

addEventListener 事件目标可以是文档上的元素 `Element`、`Document` 和 `Window` 或者任何其他支持事件的对象

语法：target.addEventListener(type, listener, options/useCapture)
1. type: 表示监听事件类型的字符串
2. listener: 所监听的事件触发，会接受一个事件通知对象
3. options: 一个指定有关 `listener` 属性的可选参数对象。可选值有 `capture`（事件捕获阶段传播到这里触发）、`once`（在 `listener` 添加之后最多只调用一次）、`passive`（设置为 `true` 时表示 `listener` 永远不会调用 `preventDefault()`）
4. useCapture：在 DOM 树中，注册了 listener 的元素，是否要先于它下面的 EventTarget 调用该 listener

> addEventListener 的第三个参数涉及到冒泡和捕获，为 true 时是捕获，为 false 时是冒泡

> 或者是一个对象 { passive: true }，针对的是 Safari 浏览器，禁止/开启使用滚动的时候要用到

+ 示例：实现了点击 `two` 切换到 `four`，点击 `four` 再切换到 `two` 的效果
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>监听器</title>
</head>
<body>
    <table id="outside">
        <tr><td id="t1">one</td></tr>
        <tr><td id="t2">two</td></tr>
    </table>
</body>
<script>
    (function() {
    // 添加函数
    const modifyText = (text) => {
        const t2 = document.querySelector('#t2');
        if (t2.firstChild.nodeValue === text) { // nodeValue:节点值，属性节点和文本节点有值，而文档节点和元素节点没有值
            t2.firstChild.nodeValue = 'two';
        } else {
            t2.firstChild.nodeValue = text;
        }
    }

    // 给 Table 添加事件监听器
    const element = document.querySelector('#outside');
    element.addEventListener('click', function() {
        modifyText('four')
    }, false);
    })()
</script>
</html>
```

### 原理

事件捕获和事件冒泡分别是 **网景**（Netscape）和 **IE** 对 `DOM` 事件产生顺序的描述

**网景** 认为 `DOM` 接收的事件应该最先是 `window`，然后到 `document`，接着一层一层往下，最后才到具体的元素接收到事件，即 **事件捕获**

**IE** 则认为 `DOM` 事件应该是具体元素先接收到，然后再一层一层往上，接着到 `document`，最后才到 `window`，即 **事件冒泡**

最后 **W3C** 对这两种方案进行了统一：将 `DOM` 事件分为两个阶段，事件捕获和事件冒泡阶段

当一个元素被点击，首先是事件捕获阶段，`window` 最先接收事件，然后一层一层往下捕获，最后由具体元素接收；之后再由具体元素再一层一层往上冒泡，到 `window` 接收事件

所以：

+ **事件冒泡**：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发（前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了 `click` 事件就触发父元素的 `click`）

+ **事件捕获**：和冒泡相反，会从上层传递到下层

### 案例

自定义事件
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>自定义事件</title>
</head>
<body>
    <ul class="ul">
        <li class="li">
            <button class="btn">点我</button>
        </li>
    </ul>
</body>
<script>
    window.onload = function() { // 用于在网页加载完毕后立刻执行的操作（即 HTML 文档加载完毕后，立刻执行某个方法）
        // 创建 Event对象，参数表示事件类型
        const myEvent = document.createEvent('CustomEvent');
        // 初始化 Event对象的属性，事件类型，是否冒泡，是否阻止浏览器默认行为
        myEvent.initEvent('myEvent', true, true);

        const btn = document.querySelector('.btn');
        btn.addEventListener('myEvent', (e) => {
            console.log('button');
        })

        const li = document.querySelector('.li');
        li.addEventListener('myEvent', (e) => {
            console.log('li');
        })

        const ul = document.querySelector('.ul');
        ul.addEventListener('myEvent', (e) => {
            console.log('ul');
        })

        document.addEventListener('myEvent', (e) => {
            console.log('document');
        })

        window.addEventListener('myEvent', (e) => {
            console.log('window');
        })

        setTimeout(() => {
            // 允许发送事件到监听器上 -- 触发
            btn.dispatchEvent(myEvent);
        }, 2000);
    }
</script>
</html>
```

输出结果： `button` -> `li` -> `ul` -> `document` -> `window`

如果是捕获，则相反

### 练习题

点击一个 `input` 依次触发的事件
```js
const text = document.getElementById('text');

text.onclick = function (e) {
    console.log('onclick');
} 

text.onfocus = function (e) {
    console.log('onfocus');
}

text.onmousedown = function (e) {
    console.log('onmousedown');
}

text.onmouseenter = function (e) {
    console.log('onmouseenter');
}
```

正确顺序是：`onmouseenter -> onmousedown -> onfocus -> onclick`

如果加上`onmouseup`，就是：

+ `onmouseenter -> onmousedown -> onfocus -> onmouseup -> onclick`

### 阻止冒泡

+ `event.stopPropagation()`

```js
btn.addEventListener('myEvent', function (e) {
    console.log('button');
    event.stopPropagation();
})
```

通过阻止冒泡，程序只会输出 `button`，而不会继续输出 `li` 等

### onmouseover 和 onmouseenter 区别

`onmouseover`：鼠标指针移动到指定的元素上时发生
`onmouseenter`: 鼠标指针移动到元素上时触发

这两者都是移入的时候触发，但是 `onmouseover` 会触发多次，而 `onmouseenter` 只在进去的时候才触发

### 科普

并不是所有事件都有冒泡，如：
+ `onblur`
+ `onfocus`
+ `onmouseenter`
+ `onmouseleave`



